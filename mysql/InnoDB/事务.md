## 事务的特性
- 原子性（Atomicity）
- 隔离性（Isolation）
- 一致性（Consistency）
- 持久性（Durability）


开启事务的方式：
- `begin`
- `start transaction`，这个语句后面可以跟修饰符，如果有多个修饰符需要逗号分隔，
	- `read only`：只读事务
	- `read write`：既可以读取数据，也可以修改数据
	- `with consistent snapshot`：启动一致性读

提交事务 `commit`

中止事务 `rollback`

保存点，在事务中打点就可以回滚到指定的保存点
```mysql
# 创建保存点
savepoint 保存点名称

# 回滚至某个保存点
rollback to 保存点名称

# 删除保存点
release savepoint 保存点名称
```

## 事务隔离级别
- Read Uncommitted：未提交读
- Read Committed：提交读
- Repeatable Read：可重复读
- Serializable：串行化

### 事务并发执行时的一致性问题
#### 脏写（Dirty Write）
如果一个事务修改了另一个未提交事务修改过的数据，意味着发生了脏写
#### 脏读（Dirty Read）
如果一个事务读到了另一个未提交事务修改过的数据，意味着发生了脏读
#### 不可重复读（Non Repeatable Table）
如果一个事务修改了另一个未提交事务读取的数据，意味着发生了不可重复读
#### 幻读（Phantom）
如果一个事务先根据某些搜索条件查询出一些记录，在该事务未提交时，另一个事务写入了一些符合那些搜索条件的记录（INSERT、DELETE、UPDATE），意味着发生幻读

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| -------- | ---- | ---------- | ---- |
| 未提交读 | √    | √          | √    |
| 提交读   | ×    | √          | √    |
| 可重复读 | ×    | ×          | √    |
| 串行化   | ×    | ×          | ×    | 


## MVCC
### 版本链
每次对记录的改动都会产生一个undo日志，每条undo日志有一个roll_pointer字段，通过这个字段可以将undo日志串成一个链表
![[Pasted image 20220330034145.png]]

### ReadView
readview包含四个属性：
- m_ids：表示在生成readview时当前系统中活跃的读写事务的事务id列表
- min_trx_id：在生成readview时当前系统中活跃的读写事务中最小的事务id，即m_ids中最小的值
- max_trx_id：生成readview时系统中应该分配给下一个事务的id值
> 注意max_trx_id并不是m_ids中的最大值，事务id是递增分配的。比方说现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，m_ids就包括1和2，min_trx_id的值就是1，max_trx_id的值就是4
- creator_trx_id：生成该readview的事务的事务ID

判断某个版本是否可见时：
- 访问版本trx_id与readview中的creator_trx_id值相同，表示当前事务在访问它自己修改过的记录，该版本可被当前事务访问
- 访问版本trx_id小于readview中的min_trx_id值，表示该版本的事务在当前事务生成readview时已经提交，所以该版本可被当前事务访问
- 访问版本trx_id大于等于readview的max_trx_id值，表示生成该版本的事务在当前事务生成readview后才开启，所以该版本不可被当前事务访问
- 访问版本trx_id在readview的min_trx_id和max_trx_id之间，需要判断trx_id值是否在m_ids中，如果在表示创建readview时该版本事务还是活跃状态不可被访问；如果不在说明创建readview时生成该版本的事务已经被提交，该版本可被访问

如果某个版本的数据对当前事务不可见的话，就顺着版本链找到下一个版本，继续按照上面的逻辑进行判断，直到最后一个版本，如果最后一个版本也不可见，则意味着该条记录对该事务完全不可见，就不会查询到结果。

提交读：每次读取数据前都生成一个readview
重复读：在第一次读取数据时生成一个readview