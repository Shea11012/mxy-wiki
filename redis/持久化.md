---
tags: []
date created: 2022-04-09 03:42
date modified: 2023-04-10 03:25
title: 持久化
---
Redis 持久化分为两种：AOF、RDB、混合持久化

## RDB

RDB 持久化是把当前进程数据生成快照保存到硬盘的过程，触发 RDB 持久化过程分为手动触发和自动触发。

**手动触发分别对应 save 和 bgsave 命令**

- save：阻塞当前 redis 服务器，直到 RDB 过程完成
- bgsave：redis 进程执行 fork 操作创建子进程，RDB 持久化过程由子进程负责，完成后自动结束。阻塞只发生在 fork 阶段。

除了手动触发，redis 内部的自动触发机制，如下：

1. 使用 save 配置，`save m n` 表示 m 秒内数据集存在 n 次修改，自动触发 bgsave，通常设置在 5 分钟保存 1 次
2. 如果从节点执行全量复制操作，主节点自动执行 bgsave 生成 RDB 文件并发送给从节点
3. 执行 `debug reload` 命令重新加载 redis
4. 默认情况下执行 `shutdown` ，如果没有开启 AOF 持久化则自动执行 bgsave

**优点：**

> RDB 是一个紧凑压缩的二进制文件，代表 Redis 在某个时间点上的数据快照。适用备份，全量复制等场景。如每 6 小时执行 bgsave 备份并把 RDB 文件拷贝到远程机器或者文件系统中，用于灾难恢复。
> RDB 加载速度快于 AOF。

**缺点：**

> RDB 没有办法做到实时持久化、秒级持久化。因为 bgsave 每次运行都要执行 fork 操作创建子进程，属于重量级操作，频繁执行成本过高。
> RDB 使用特定二进制格式保存，会存在老版本服务无法兼容新版本的问题。

## AOF

AOF 持久化，将 redis 执行的写命令记录到单独的日志文件中，当 redis 重启时再次执行 AOF 文件中的命令来恢复数据。AOF 的主要作用是解决数据持久化的实时性。**AOF 只会记录写操作命令，读操作命令不会被记录**

AOF 默认不开启，设置配置 `appendonly yes`

AOF 命令写入的内容是文本协议格式。

AOF 缓冲区同步文件策略，由参数 `appendfsync` 控制：

- always：每次写操作命令执行完成后，同步将 AOF 日志数据写回硬盘
- everysec：每次写操作命令执行完后，将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区的内容写回到硬盘
- no：每次写操作命令执行完后，将命令写入到 AOF 文件的内核缓冲区，由操作系统决定何时将缓冲区内容写回硬盘

### AOF 重写过程

AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到新的 AOF 文件，等全部记录完后，就将新的 AOF 文件替换现有的 AOF 文件

重写 AOF 过程是由后台子进程 bgrewriteaof 来完成，重写过程中，主进程依然可以正常处理命令。因为子进程会拥有主进程的数据副本
>[!note] 子进程如何拥有主进程的数据副本
>主进程在生成 bgrewriteaof 子进程时，操作系统会把主进程的页表复制给子进程，这个页表记录着虚拟地址和物理地址的映射关系，而不会复制物理内存。这样子进程就共享了父进程的物理内存数据。
>当主进程或子进程向这个内存发起写操作时，CPU 会触发写保护中断，写保护中断是由于违反权限导致的，操作系统会在写保护中断处理函数里进行物理内存复制，并重新设置内存映射关系，将父子进程的内存读写权限设置为可读写，最后才对内存进行写操作，这个过程被称为 **写时复制**

当重写 AOF 过程中，如果主进程修改了已经存在的 kv，那么会发生写时复制，此时子进程与主进程内存数据不一致，为了解决数据不一致的问题，Redis 设置了 **AOF 重写缓冲区**，这个缓冲区在 bgrewriteaof 子进程后开始使用。

在 bgrewriteaof 子进程执行 AOF 期间，主进程执行三个工作：
- 执行客户端命令
- 将执行后的写命令追加到 AOF 缓冲区
- 将执行后的写命令追加到 AOF 重写缓冲区

当子进程完成 AOF 重写，会向主进程发送一个异步信号，主进程收到信号后：
- 将 AOF 重写缓冲区所有内容追加到新的 AOF 文件中
- 新的 AOF 文件改名，覆盖现有 AOF 文件

## 混合持久化

混合持久化结合了 AOF 和 RDB，即保证 redis 重启速度，又降低了数据丢失风险。

在 redis 配置文件增加：
```
aof-use-rdb-preamble yes
```

开启混合持久化时，在 AOF 重写时，fork 的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程再将 AOF 重写缓冲区的命令以 AOF 的方式追加到 AOF 文件，写入完成后通知主进程将新文件替换旧文件。**即前半部分是 RDB 格式数据，后半部分是 AOF 格式数据**

## 大 key 对持久化的影响

- 客户端超时阻塞。因为 redis 执行命令是单线程，在操作大 key 时会比较耗时
- 引发网络阻塞。如果一个 key 的大小是 1MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流程，对于普通的千兆网卡是灾难性的。
- 阻塞工作线程。使用 del 删除大 key 时，会阻塞工作线程。
- 内存分布不均匀。集群模式下 slot 分片均匀情况下，会出现数据和查询倾斜，部分大 key 的 redis 节点占用内存多，QPS 也会比较大

### 如何避免大 key

在设计阶段，把大 key 拆分成一个个小 key，或者定时检查 redis 是否存在大 key。
删除大 key，用 unlink 命令，该命令删除过程是异步的。