---
tags: 
date created: 2022-03-16 14:13
date modified: 2023-11-09 15:07
title: TCP
---

# TCP

TCP 是一个可靠的 (reliable)、面向连接 (connection-oriented)、基于字节流 (byte-stream)、全双工 (full-duplex) 的协议。发送端在发送数据后启动一个定时器，如果超时没有收到对端确认会进行重传，接收端利用序列号对收到的包进行排序、丢弃重复的数据，TCP 还提供了流量控制、拥塞控制等机制保证稳定性。

![](https://mxy-imgs.oss-cn-hangzhou.aliyuncs.com/imgs/202110211708548.webp)


![](https://mxy-imgs.oss-cn-hangzhou.aliyuncs.com/imgs/202110211652294.webp)

# TCP 四元组

源 IP、源端口、目标 IP、目标端口构成了 TCP 连接的四元组。一个四元组可以唯一标识一个连接。

# 序列号

序列号是一个 32 位无符号的整数，达到 2^32-1 后循环到 0。
TCP 传输的字节流的每个字节都分配了序列号，序列号指本报文段第一个字节的序列号。
序列号加上报文长度，就可以确定传输的是哪一段数据。
> 在 SYN 报文中，序列号用于交换彼此的初始序列号。在其他报文中，序列号用于保证包的顺序。

# 确认号

TCP 使用确认号来告知对方下一个期望接受的序列号，小于此确认号的所有字节都已收到。
> ACK 包不需要被确认

# TCP flags

TCP flag 定义为 8 位
常用位：
- SYN（Synchronize）：用于发起连接数据包同步双方的初始序列号
- ACK（Acknowledge）：确认数据包
- RST（Reset）：强制断开连接
- FIN（Finish）：发完所有数据，准备断开连接
- PSH(Push)：这些数据包收到以后应该马上交给上层应用，不能缓存

# IP 分段

![ip|740](https://mxy-imgs.oss-cn-hangzhou.aliyuncs.com/imgs/202110261153584.webp)

ipv4 数据包最大为 65535 字节。当一个 IP 数据包大于 MTU 时，IP 会把数据报文进行切割为多个小的片段，使得这些小的报文可以通过链路层进行传输。

## TCP 最大段大小（Max Segment Size,MSS）

TCP 为了避免被发送方分片，会主动把数据分割成小段再交给网络层，最大分段大小被称为 MSS。
MSS 计算公式：`MSS= MTU - IP Header Size - TCP header size`

# 可选项

![](https://mxy-imgs.oss-cn-hangzhou.aliyuncs.com/imgs/202110261115291.webp)

## TCP 头部时间戳可选项（TCP Timestamps Option,TSopt）

TSopt 由四部分构成：
- 类别 (kind)，kind = 8
- 长度 (length)，length = 10
- 发送方时间戳 (Ts value)
- 回显时间戳 (TS Echo Reply)

发送方发送数据时，将发送时间戳放在 TSval 中
接受方接受到数据包时，将收到的时间戳放在 TSecr 中，将自己的时间戳放在 TSval 中。

TSopt 的作用：
- 测量出两端往返所消耗的时间（RTTM）
- 序列号回绕（PAWS）

## 窗口大小（Window Size）

窗口大小为 16 位，最大窗口大小为 2^16-1 即 65535 字节等于 64kb，这是以前的内存短缺时的设计。

因为设计的缺陷，TCP 引入了 **TCP 窗口缩放**比例因子，选项类型为 3，长度为 3 字节，包含 1 字节数据（1 字节能表示最大值为 255）。0 表示不缩放。比例因子可以将窗口扩大到原来的 2^n 。如：窗口大小 1050，缩放因子 7，则真正的窗口大小为 1050 * 2^7 大小。

一般情况下，窗口大小在三次握手阶段后就保持不变。

# 半连接、全连接队列

- 半连接队列（Incomplete connection queue），SYN 队列
- 全连接队列（Completed connection queue），Accept 队列

# 检验和（checksum）

每个 TCP 包首部都有两个字节来表示检验和，防止在传输过程中有损坏。如果收到一个校验和有差错的报文，TCP 不会发送任何确认直接丢弃它，等待发送端重传。
> 包的序列号保证接收数据的乱序和重复问题

# 超时重传 

TCP 发送数据后会启动一个定时器，等待对端确认收到这个数据包。如果在指定时间内没有收到 ACK 确认，就会重传数据包，然后等待更长时间。在多次重传仍然失败后，TCP 会放弃这个包。

# 接收缓冲区

- TCP 包是承载在 IP 包上，且 IP 包是独立路由可能走不同的网络路径，无法保证按序送达。
- 数据到达目标主机后，应用程序可能无法立即接收数据。
基于以上两点，TCP 需要在内存中准备一个接收缓冲区，用于临时保存数据。
TCP 报文到达后，数据先临时保存在缓冲区，位置由序号决定。当相邻数据到达后，组成连续字节流提交给应用程序。当数据被取走后，缓冲区副本就可以删除。

所以 TCP 缓冲区的主要作用：
- 应用进程繁忙是暂存数据
- 数据乱序到达时重排数据

# 流量控制

发送方不能无脑的发数据给接受方，如果一直无脑发送给对方，但对方处理不过来，就会导致触发重传机制，从而导致网络流量的浪费。

流量控制：TCP 提供一种机制让发送方根据接受方的实际接受能力控制发送的数据

**滑动窗口**就是一种流量控制，接受方通过 ACK 报文告知发送方窗口大小。
- 窗口为 0 时，会阻止发送方发送数据，并会启动一个定时器，如果定时器超时就会发送窗口探测报文，而接受方就会告知窗口大小。窗口探测一般发送 3 次，每次大约 30~60 秒，3 次后如果窗口大小还是 0，发送方就会发 RST 报文来中断连接。
- 为了避免接受方仅有几个字节的窗口大小时也发送报文，有限制当窗口大小<min(MSS,缓存空间/2)，就会向发送发告知窗口为 0

# 拥塞控制

在网络出现拥堵时，如果继续发送大量的数据包可能会导致数据包时延、丢失等，这时 TCP 会重传数据，但一重传就会导致网络的负担更重，于是导致更大的延迟以及更多的丢包就进入了恶性循环，所以需要拥塞控制。

拥塞控制避免发送方的数据填满整个网络，当发生超时重传，就会认为网络出现了拥塞。

拥塞窗口 `cwnd` 由发送方维护的一个状态变量，会根据网络的拥塞程度动态变化。
接口窗口 `rwnd` 发送窗口 `swnd`
因为加入了拥塞窗口，则 cwnd=min(cwnd,rwnd)
拥塞控制的四个算法：
- 慢启动
- 拥塞避免
- 快速重传
- 快速恢复

## 慢启动

当 TCP 刚建立连接时，发送窗口一般都比较小。比如一开始只有 10 字节，当每收到一次 ack，窗口大小都指数级增长，从 10、20、40、80、160 这样增长。一旦增长到一定水平，就会降为线性增长，直到到达设定的上限。

慢启动有一个 `ssthresh (slow start threshold)` 变量
- 当 `cwnd < ssthresh` 时使用慢启动算法
- 当 `cwnd >= ssthresh` 使用拥塞避免算法

## 拥塞避免算法

当网络容量被一个突发流量占用，导致同一链路下的所有连接都出现丢包。当突发流量消失时，其他连接应该充分利用被释放的网络容量。

为了温和的找出额外的可用容量，不对网络产生冲击，使用拥塞避免算法。当拥塞窗口 cwnd 不低于 ssthresh 时，就会执行该算法。

一般 ssthresh 大小为 65535 字节
拥塞避免算法：每收到一个 ACK，cwnd 增加 1/cwnd

## 快速重传

随着 cwnd 一直增长，网络发生拥塞，数据出现丢包，触发重传机制，同时将 cwnd 减半，执行拥塞控制。重传机制分两种：
- 超时重传
- 快速重传

超时重传，会使用拥塞发生算法，首先将 `ssthresh` 设为 `cwnd/2` 并重置 `cwnd` 为 1，接着就会进入慢启动算法

快速重传，当接受方发现丢了一个中间包时，发送 3 次前一个包的 ACK，于是发送方就会快速重传，不必等待超时重传

## 快速恢复

有时遇到偶发性丢包，网络不一定是阻塞的，此时会跳过慢启动，进入拥塞避免阶段。

快速恢复与快速重传一般同时使用，当收到连续 3 个重复的 ACK 时表明网络不是很糟糕，就会进入快速恢复算法。
