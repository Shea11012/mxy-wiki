---
date created: 2022-04-10 00:23
date modified: 2022-04-10 00:31
title: 内部结构
---
## 简单动态字符串 SDS
Redis 自己构建了一种简单动态字符串（simple dynamic string，SDS），并将 SDS 用作 Redis 的默认字符串表示。

1. 空间预分配

空间预分配用于优化 SDS 的字符串增长操作，当 SDS 的长度小于 1MB 。

例如：当 SDS 的 len 长度为 13 字节，那么程序也会分配 13 字节的未使用空间，SDS 的 buf 数组的实际长度将变成 13+13+1 字节的长度（额外一字节用于保存空字符），如果 SDS 的长度大于等于 1 MB，程序则会分配 1MB 的未使用空间，buf 的实际长度为 SDS 长度 + 1MB + 1byte 。

空间预分配策略，减少了连续执行字符串增长所需的内存重分配次数。

2. 惰性空间释放

惰性空间释放用于优化 SDS 的字符串缩短操作，当 SDS 需要缩短 SDS 保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用 free 属性将这些字节数量记录起来，等待将来使用。

例如：原 SDS 共有字节数 11 ，当缩短了 8 后，这个 8 字节会被记录在 free 属性中。

## 链表 Linked List
  Redis 链表实现特性：
  - 双端：链表节点带有 prev 和 next 指针，获取某个节点的前置节点和后置节点复杂度都是 $O(1)$
  - 无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL，对链表的访问以 NULL 为终点
  - 带表头指针和表尾指针：通过 list 结构的 head 指针和 tail 指针，程序获取链表的表头节点和表尾节点的复杂度为 $O(1)$
  - 带链表长度计数器：程序使用 list 结构的 len 属性来对 list 持有的链表节点进行计数，程序获取链表中节点数量的复杂度为 $O(1)$
  - 多态：链表节点使用 void* 指针来保存节点值，并且可以通过 list 结构的 dup、free、match 三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值
  
## 压缩列表 ziplist
压缩列表是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那 Redis 就会使用压缩列表
### 压缩列表节点构成
**字节数组：**
- 长度小于等于 $64(2^6-1)$ 字节的字节数组
- 长度小于等于 $16383(2^14-1)$ 字节的字节数组
- 长度小于等于 $4294967295(2^{32}- 1)$ 字节的字节数组

**整数值：**
- 4 位长，介于 0 至 12 之间的无符号整数
- 1 字节长的有符号整数
- 3 字节长的有符号整数
- int16_t 类型整数
- int32_t 类型整数
- int64_t 类型整数

## 整数集合 intset

集合键的底层实现之一，可以保存类型为 int16_t 、int32_t  、 int64_t 的整数值，并且保证集合中不会出现重复的元素。

整数集合会根据新添加的元素类型，改变这个数组的类型。

整数集合只支持升级操作，不支持降级操作

## 字典 Dict

Redis 数据库就是使用字典来作为底层实现的

哈希表的扩展与收缩，当以下条件中任意一个被满足，程序自动开始哈希扩展：

1. 服务器目前没有执行 BGSAVE 或者 BGREWRITEAOF 命令，并且哈希表的负载因子大于等于 1。
2. 服务器目前没有执行 BGSAVE 或者 BGREWRITEAOF 命令，并且哈希表的负载因子大于等于 5。

> 哈希表的负载因子计算公式：load_factor = ht[0].used / ht[0].size

## 跳跃表 Skip List

Redis 有序集合使用跳跃表作为底层实现之一

每个跳跃表节点的层高都是 1 至 32 之间的随机数

在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的

跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序

## 对象

Redis 数据库以对象的形式实现，键一直是字符串对象，值可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象其中的一种