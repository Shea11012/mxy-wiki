---
tags:
  - 缓存
date created: 2021-12-03 20:20
date modified: 2023-104-10 70444:01
---

## 缓存更新策略

1. LRU、LFU、FIFO 淘汰算法，在 redis 中只需配置 maxmemory 和选择对应的算法。数据的一致性最差
2. 超时淘汰，在过期时间内可能存在数据不一致
3. 主动更新，一致性最高，可以结合超时淘汰（有可能有些数据会长时间不被更新）

低一致性业务可以使用最大内存和淘汰策略

高一致性业务可以结合超时淘汰和主动更新，这样即使主动更新出了问题，也能保证数据过期时间后删除脏数据。

## 穿透优化

缓存穿透是指一个根本不存在的数据，缓存层和存储层都不会命中，通常出于容错考虑，如果存储层查不到数据则不写入缓存层。

解决办法：

1. **缓存空对象**：针对这类数据设置一个较短的过期时间。为了避免缓存层和存储层的数据会有一段时间的不一致，如：给空对象设置了过期时间为 5 分钟，如果此存储层此时添加了这个数据，那么此段时间的数据不一致，可以利用消息系统或者其他方法清除掉缓存层中的空对象。

适用场景：数据命中不高，数据频繁变化实时性高

1. **布隆过滤器**：在访问缓存层和存储层之前，将存在的 key 用布隆过滤器提前保存，如果布隆过滤器认为该用户不存在则不会访问存储层。

适用场景：数据命中不高，数据相对固定实时性低

## 无底洞优化

问题：在一个有着 3000 个节点的集群中，因为性能问题而继续添加节点，却发现性能不但没有好转反而下降。

原因：键值数据库通常采用哈希函数将 key 映射到各个节点上，由于数据量好访问量的持续增长，需要添加大量节点做水平扩容，导致键值分布到更多节点上。无论 memcache 还是 redis 的分布式，批量操作通常需要从不同节点上获取，相比于单机批量操作只涉及一次网络操作，分布式批量操作会涉及多次网络时间。**客户端一次批量操作会涉及多次网络操作，意味着批量操作会随着节点的增多，耗时会不断增大。网络连接数变多，对节点的性能也有一定影响。**

解决方法：

1. 串行命令，获取 n 个 key 的值逐次执行 n 个 get 的命令，时间复杂度 = n 次网络时间 +n 次命令时间
2. 串行 IO：根据 redis 计算插槽的方法，手动计算（CRC16 计算散列值，再对 16384 取余），根据这个数据将同一个节点的 key 归档，之后再对个每个节点执行 mget 或者 pipeline 操作。时间复杂度=node 次网络时间 +n 次命令时间。
3. 并行 IO：将串行 IO 改为多线程执行。
4. hash_tag：将多个 key 强制分配到一个节点上

## 雪崩优化

缓存雪崩：由于缓存层承载着大量请求，有效的保护了存储层，但如果缓存层由于某些原因不能提供服务，于是所有的请求都会到达存储层，存储层的调用量会暴增，造成存储层也会级联宕机。

解决方法：

1. 保证缓存层服务高可用
2. 依赖隔离组件为后端限流并降级

## 热点 key 重建优化

缓存 + 过期时间的策略可以加速数据读写，又保证数据的定期更新，但会有两个问题如果同时出现，可能会对应用造成致命的危害：

- 当前 key 是一个热点 key，并发量非常大
- 重建缓存不能再短时间完成，可能是一个复杂的计算

缓存失效的瞬间，有大量线程来重建缓存，造成后端负载加大，可能会让应用崩溃。

解决办法：

1. 互斥锁：此方法只允许一个线程重建缓存，其它线程等待重建缓存的线程执行完，重新从缓存获取数据。
2. 永不过期：从缓存层不设置过期时间，在代码层为每个 value 设置一个逻辑过期时间，当发现超过逻辑过期时间后，重建缓存。