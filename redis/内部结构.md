---
tags: []
date created: 2022-04-10 00:23
date modified: 2023-04-09 16:35
title: 内部结构
---

## 简单动态字符串 SDS

Redis 自己构建了一种简单动态字符串（simple dynamic string，SDS），并将 SDS 用作 Redis 的默认字符串表示。

1. 空间预分配

空间预分配用于优化 SDS 的字符串增长操作，当 SDS 的长度小于 1MB 。

例如：当 SDS 的 len 长度为 13 字节，那么程序也会分配 13 字节的未使用空间，SDS 的 buf 数组的实际长度将变成 13+13+1 字节的长度（额外一字节用于保存空字符），如果 SDS 的长度大于等于 1 MB，程序则会分配 1MB 的未使用空间，buf 的实际长度为 SDS 长度 + 1MB + 1byte 。

空间预分配策略，减少了连续执行字符串增长所需的内存重分配次数。

2. 惰性空间释放

惰性空间释放用于优化 SDS 的字符串缩短操作，当 SDS 需要缩短 SDS 保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用 free 属性将这些字节数量记录起来，等待将来使用。

例如：原 SDS 共有字节数 11 ，当缩短了 8 后，这个 8 字节会被记录在 free 属性中。

## 链表 Linked List

  Redis 链表实现特性：
  - 双端：链表节点带有 prev 和 next 指针，获取某个节点的前置节点和后置节点复杂度都是 $O(1)$
  - 无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL，对链表的访问以 NULL 为终点
  - 带表头指针和表尾指针：通过 list 结构的 head 指针和 tail 指针，程序获取链表的表头节点和表尾节点的复杂度为 $O(1)$
  - 带链表长度计数器：程序使用 list 结构的 len 属性来对 list 持有的链表节点进行计数，程序获取链表中节点数量的复杂度为 $O(1)$
  - 多态：链表节点使用 void* 指针来保存节点值，并且可以通过 list 结构的 dup、free、match 三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值
  

## ~~压缩列表 ziplist~~

> Redis7.0 中，压缩列表已经废弃，由 listpack 代替

压缩链表被设计成一种内存紧凑的数据结构，占用一块连续的内存空间，可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码。

缺陷：
- 不能保存过多的元素，否则查询效率就会降低
- 新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新

## 整数集合 intset

集合键的底层实现之一，可以保存类型为 int16_t 、int32_t 、 int64_t 的整数值，并且保证集合中不会出现重复的元素。

整数集合会根据新添加的元素类型，改变这个数组的类型。

整数集合只支持升级操作，不支持降级操作

## Hash

redis 使用链式哈希来解决哈希冲突

### 渐进式 rehash

在正常服务请求阶段，数据都会写入到哈希表 1，随着数据逐步增多，触发 rehash 操作：
- 给哈希表 2 分配空间，一般会比哈希表 1 大 2 倍
- 在 rehash 期间，每次哈希表元素进行新增、删除、查找或者更新操作时，redis 都会执行对应的操作，还会顺序将哈希表 1 中的索引位置上的所有 kv 迁移到哈希表 2
- 在某个时间点将哈希表 1 的所有 kv 迁移到哈希表 2，从而完成 rehash

**rehash 触发条件**
负载因子= 哈希表已保存节点数量/哈希表大小
触发 rehash 操作条件：
- 当负载因子>=1，并且 redis 没有在执行 bgsave 或 bgrewriteaof，就会进行 rehash
- 当负载因子>=5，说明哈希冲突非常严重，不管有没有执行 RDB 或 AOF，都会进行 rehash

## 跳跃表 Skip List

Redis 有序集合使用跳跃表作为底层实现之一

每个跳跃表节点的层高都是 1 至 32 之间的随机数

在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的

跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序

### 为什么用跳表而不用平衡树

- 跳表不是内存密集的，更改参数将使其比 btree 占用更少内存
- zset 经常需要执行 zrange 或 zrevrange，即作为链表遍历跳表，此操作跳表的缓存局部性比平衡树好
- 从内存占用上比较，跳表比平衡树更灵活
- 做范围查找时，跳表比平衡树操作简单
- 从算法实现难度来比较，跳表比平衡树简单的多，更易于实现、调试

## quicklist

quicklist 是 【双向链表 + 压缩列表】组合，一个 quicklist 是一个链表，而链表中的每个元素又是压缩列表

quicklist **通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题，因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能**

## listpack

quicklist 未完全解决连锁更新问题，redis 用了一个新的数据结构 listpack，来替代压缩列表。
listpack 只记录当前节点的长度，当向 listpack 加入一个新元素时，不会影响其他节点的长度字段变化，从而避免了压缩列表的连锁更新问题。