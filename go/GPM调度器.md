## Goroutine & Scheduler
### 操作系统三种线程模型：
#### 内核级线程模型
此模型下线程的切换调度由系统内核完成，系统内核负责将多个线程执行的任务映射到各个cpu中执行，直接使用操作系统内核来创建、销毁、切换和调度，对性能影响很大。
#### 用户级线程模型
多个用户线程一般从属于单个进程且多线程的调度是由用户自己完成的。这种实现方式相比内核线程很轻量，对系统资源的消耗很小，上下文切换代价也很小。但是并不能真正意义上做到并发，如果进程内的某个线程发生阻塞调用从而被CPU调度，会导致整个进程被挂起。
#### 混合线程模型
一个进程可以与多个内核线程KSE（kernel schedule entity）关联。进程里的线程并不与KSE唯一绑定，而是多个用户线程映射到同一个KSE，当某个KSE因为其绑定的线程阻塞操作被内核调度出CPU时，其关联的进程中其余用户线程可以重新与其它KSE绑定运行。
goroutine和 go scheduler 在底层实现上是属于混合线程模型

## GPM 模型
每个OS线程的大小根据操作系统的不同大约在1~8MB，这对于goroutine来说很大。
在Go中，每一个goroutine的初始大小为2kb，采取动态扩容的方式，随着任务执行按需增长，且完全由 Go Scheduler 调度。
### G
表示goroutine，每个goroutine对应一个G结构体，G存储的Goroutine的运行堆栈、状态以及任务函数，可重用。G并非执行体，每个G需要绑定到P才能调度执行。
### P
表示逻辑处理器（Processor），对G来说，P相当于CPU，G只有绑定到P（P的local runq中）才能被调度。对M来说，P提供了相关的执行环境。P的数量决定了系统内最大可并行的G数量，P的数量由GOMAXPROCS决定，但P的最大数量为256.
### M
OS线程抽象，表示真正的执行计算资源，在绑定有效的P后，进入schedule循环。
schedule循环机制大致是从Global队列、P的local队列以及wait队列中获取G，切换到G的执行栈上并执行G的函数，调用goexit做清理工作并回到M，如此反复。M并不保留G状态，M的数量是不确定的，由Go runtime调整，M的最大数量为 10000 个。