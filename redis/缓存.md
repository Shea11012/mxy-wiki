---
tags: ["缓存"]
date created: 2021-11-30 21:22
date modified: 2023-04-11 03:12
---

## 缓存雪崩

当大量缓存数据在同一时间过期或 Redis 宕机，会有大量的请求进入到 DB 上面，导致 DB 挂掉。

### 针对数据过期

**均匀设置过期时间**
在对缓存数据设置过期时间时，给数据的过期时间加上一个随机数

**互斥锁**
如果发现访问的数据不再 redis 里，加一个互斥锁，保证同一时间内只有一个请求来构建缓存

**后台更新缓存**
不设置缓存过期时间，将更新缓存的工作交由后台线程更新。在业务发现缓存失效后，通过消息队列发送一条消息通知后台线程更新缓存。

### redis 故障宕机

**服务熔断或请求限流机制**
- 服务熔断，暂停业务应用对缓存服务的访问，直接返回错误，不再访问数据库，降低对数据库的压力，等到 Redis 恢复正常后，再允许业务访问缓存服务。
- 请求限流，只将少部分请求发送到数据库进行处理，拒绝大部分的请求，等到 Redis 恢复正常并把缓存预热后，再解除请求限流。

**构建 Redis 缓存高可靠集群**
通过构建主从节点的集群，当主节点故障，从节点可以切换为主节点，继续提供缓存服务。

## 缓存击穿

缓存中的某个热点数据过期，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮。

两种方案：
- **互斥锁方案**：保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待释放后重新读取缓存，要么返回空值或默认值
- 不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间

## 缓存穿透

当用户访问的数据，既不在缓存中，也不在数据库中。当有大量请求到来，数据库压力增大。

缓存穿透一般发生在：
- 业务误操作，缓存中的数据和数据库中的数据都被误删除了，导致缓存和数据库中都没有数据
- 黑客恶意攻击，故意访问某些不存在的数据业务

### 解决办法：

**非法请求的限制**
判断请求参数是否合理，请求参数是否有非法值，请求字段是否存在，如果是恶意请求就直接返回错误

**缓存空值或默认值**
当发现缓存穿透现象时，可以针对查询的数据，在缓存中设置一个空值或默认值

**使用布隆过滤器判断数据是否存在**
在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，确认缓存失效后，可以通过查询布隆过滤器判断数据是否存在，通过布隆过滤器避免了数据库遭到过大的压力。

## 数据库和缓存如何保存一致性

**先更新数据库、再删除缓存**，但是每次更新数据时，缓存的数据都会被删除，会对缓存命中率带来影响，**如果业务对命中率要求很高，应该采用【更新数据库 + 更新缓存】**

>[!tip] 更新数据库 + 更新缓存的问题
> 因为更新数据库和更新缓存是两个独立的操作，当两个线程并发更新时，会因为写入顺序不同造成数据不一致
> 解决办法：
> - 更新缓存前加分布式锁，保证同一时间只运行一个请求更新缓存，就不会产生并发问题，引入了锁，对于写入性能会带来影响
> - 在更新完缓存时，给缓存加上较短的过期时间，这样即使出现缓存不一致，缓存的数据与会很快过期


**【先删除缓存，再更新数据库】** 方案，在读 + 写并发请求而造成缓存不一致的解决办法时 **延迟双删**

```
# 删除缓存
redis.delkey()

# 更新数据库
db.update()

# 睡眠
sleep()

# 再删除缓存
redis.delkey()
```

加睡眠时间，是为了确保请求 A 在睡眠的时候，请求 B 能够在这一段时间能完成从数据库读取数据，再把缺失的缓存写入缓存的操作，然后请求 A 睡眠完，再删除缓存。但是具体的睡眠时间不好把握，所以还是建议用 **先更新数据库，在删除缓存的方案**

针对 **先更新数据库，在删除缓存** 方案，要保证两个操作都能执行成功，有两种解决方法：
- 重试机制，通过引入消息队列，当重试超过阈值，向业务层报错
- 订阅 MySQL binlog，再操作缓存
