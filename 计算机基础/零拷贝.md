#### 传统的IO调用
通过read()把数据从硬盘读取到内核缓冲区，再复制到用户缓冲区，然后再通过 write() 写入到 socket 缓冲区，最后写入网卡。
整个过程发生了**4次用户态和内核态的上下文切换与4次拷贝**，具体流程如下：
1. 用户进程通过 read() 方法向操作系统发起调用，此时上下文从用户态切换到内核态
2. [[名词解释#DMA（Direct Memory Access|DMA]]  控制器把数据从硬盘拷贝到读缓冲区
3. CPU把读缓冲区数据拷贝到应用缓冲区
4. 用户进程通过 write() 发起调用，上下文从用户态切换到内核态
5. CPU将应用缓冲区中数据拷贝到 socket 缓冲区
6. [[名词解释#DMA（Direct Memory Access|DMA]] 控制器把数据从 socket 缓冲区拷贝到网卡，wirte结束，上下文从内核态切换到用户态


![](https://mxy-imgs.oss-cn-hangzhou.aliyuncs.com/imgs/202109221440859.png)

#### mmap + write
使用 mmap 替换了 read + write 中的 read 操作，减少了一次 CPU 的拷贝。
mmap 主要实现了将读缓冲区和用户态缓冲区地址进行映射，内核缓冲区和应用缓冲区共享，从而减少了从读缓冲区到用户缓冲区的一次CPU拷贝。
整个过程发生了**4次用户态和内核态的上下文切换与3次拷贝**：
1. 用户进程通过mmap方法向操作系统发起调用，上下文从用户态切换到内核态
2. [[名词解释#DMA（Direct Memory Access|DMA]]  控制器把数据从硬盘中拷贝到读缓冲区
3. 上下文从内核态转为用户态，mmap调用返回
4. 用户进程通过 write 方法发起调用，上下文从用户态转为内核态
5. CPU 将读缓冲区中数据拷贝到 socket 缓冲区
6. [[名词解释#DMA（Direct Memory Access|DMA]]  控制器把数据从 socket 缓冲区拷贝到网卡，write结束，上下文从内核态切换到用户态


![](https://mxy-imgs.oss-cn-hangzhou.aliyuncs.com/imgs/202109221619804.png)

#### sendfile
对比 mmap ，sendfile减少了一次CPU拷贝，还减少了2次上下文切换
sendfile 是 linux2.1 内核版本后引入的一个系统调用函数，通过使用 sendfile 函数可以直接在内核空间进行传输，替代了 read+write 节省了一次系统调用（2次上下文切换）
**2次用户态和内核态的上下文切换与3次拷贝**：
1. 用户进程通过 sendfile 方法向操作系统发起调用，上下文从用户态转向内核态
2. DMA 控制器把数据从硬盘拷贝到读缓冲区
3. CPU 将读缓冲区中数据拷贝到socket 缓冲区
4. DMA 控制器把数据从socket缓冲区拷贝到网卡，sendfile 结束，上下文从内核态切换到用户态

> sendfile io 数据对用户空间完全不可见，只能适用于完全不需要用户空间处理的情况。如静态文件服务器

![](https://mxy-imgs.oss-cn-hangzhou.aliyuncs.com/imgs/202109221630793.png)

#### sendfile + DMA Scatter/Gather
linux 2.4 内核版本之后对sendfile做了优化，引入了新的硬件支持，[[名词解释#DMA Scatter Gather|DMA Scatter/Gather]]。
**2次用户态和内核态上下文切换与2次拷贝**：
1. 用户进程通过 sendfile 向操作系统发起调用，上下文从用户态转向内核态
2. DMA 控制器利用 scatter 把数据从硬盘中拷贝到读缓冲区
3. CPU 把读缓冲区中的文件描述符和数据长度发送到 socket 缓冲区
4. DMA 控制器根据文件描述符和数据长度，使用 scatter/gather 把数据从内核缓冲区拷贝到网卡
5. sendfile 调用结束，上下文从内核态切换到用户态

> DMA gather  对用户空间不可见，且需要硬件支持，同时文件描述符只能是文件。


![](https://mxy-imgs.oss-cn-hangzhou.aliyuncs.com/imgs/202109221729744.png)