---
tags: []
date created: 2021-12-03 20:20
date modified: 2023-03-24 02:29
title: kafka
---

## 基本概念

消息系统：具备系统解耦、冗余存储、流量削锋、缓冲、异步通信、扩展性、可恢复性
存储系统：kafka 可以把消息持久化到磁盘，降低数据丢失风险
流式处理：提供了完整的流式处理类库

topic是一个逻辑概念，可以细分为多个分区，同一主题下的不同分区消息不同，kafka保证分区有序而不是主题有序

kafka为分区引入多副本（Replica）机制，通过增加副本数提升容灾能力

## 名词解释

名词 | 解释
------  | ------ 
producer | 生产者，发送消息
consumer|消费者，接受消息
broker|服务代理节点，一个 broker 看作一台 kafka 服务器，多个 broker 组成 kafka 集群
topic|消息以主题进行归类，主题是一个逻辑概念
partition | 消息实际存储到分区，每个主题可以有多个分区
offset | 每个分区中都有的唯一标识，通过它来保证消息在分区的顺序性
AR（Assigned Replicas）| 分区中所有副本的统称，AR=ISR+OSR
ISR（In-Sync Replicas）| 所有与 leader 副本保持一定程度同步的副本
OSR（Out-of-Sync Replicas）| 与 leader 副本同步滞后过多的副本
HW（high watermark) | 高水位，标识一个特定的消息偏移量，消费者只能拉取到这个 offset 之前的消息
LEO（Log End Offset）| 标识当前日志文件中下一条待写入消息的 offset，分区 ISR 集合中的每个副本都会维护自身的 LEO，而 ISR 集合中最小的 LEO 即为分区的 HW，对消费者而言只能消费 HW 之前的消息

### 消费者位移

`__consumer_offsets` kafka 内部的位移主题，用于保存 kafka 消费者的位移信息。

位移主题的 key 内容为<group_id、主题名、分区号>，value 则除了保存位移值，还保存了一些其他的元数据，如时间戳和用户自定义数据。

位移的消息格式：
- 保存位移值的消息格式
- 保存 consumer_group 信息的消息格式
- 删除 group 过期位移甚至是删除 group 的消息格式

## 重要的生产者参数

### acks

此参数指定分区中心必须要有多少个副本收到这条消息，才能确认这条消息是成功写入。
- acks=1。默认值为 1，即生产者发送消息之后，只要分区的 leader 副本成功写入，就会收到来自服务器的成功响应。如果发生 leader 写入成功，但在 follower 同步完成前 leader 崩溃则消息还是会丢失。
- acks=0。生产者发送消息后不需要等待任何服务端响应，如果消息从发送到写入 kafka 中发生异常，生产者无法得知异常，消息丢失。
- acks=-1。生产者发送消息之后，需要等待 ISR 中的所有副本都写入成功后，才能收到来自服务端的成功响应。tips：但这不意味着消息就一定可靠，应为在 ISR 中只有 leader 副本后，就变向的退化为了 acks=1。需要获得更高的消息可靠性需要配合 `min.insync.replicas` 等参数

### retries

此参数用来配置生产者的重试次数，默认值为 0。配置该值后，当发生异常时会在内部进行重试，而不是第一时间将错误返回给客户端。
`retry.backoff.ms` 控制重试间隔
>[!note]
>当顺序性非常重要时，需要将 `max.in.flight.request.per.connection` 配置为 1，此参数限制每个连接最多缓存的请求数

### connections.max.idle.ms

控制多久后关闭闲置的连接

### linger.ms

指定生产者发送 producerBatch 之前等待更多消息加入，直到 producerBatch 被写满或到了指定时间才会发送

### request.timeout.ms

配置 producer 等待请求响应的最长时间，请求超时之后可以选择进行重试。该值需要比 broker 端参数 `replica.lag.time.max.ms` 值要大，这样可以减少因客户端重试而引起的消息重复概率

## 消费者与消费组

消费组是一个逻辑概念，它将消费者归为一类，每一个消费者只能对应一个消费组，通过消费者客户端参数 `group.id` 配置，默认空字符串

消费者是实际的应用实例，同一个消费组内的消费者可以部署在同一台机器上，也可以部署在不同的机器上

- 如果所有消费者都属于同一个消费组，那么所有消息都会被均匀的分散到每一个消费者，即每条消息只会被一个消费者处理
- 如果所有的消费者来自不同的消费组，那么所有的消息都会被广播给所有消费者，即每条消息会被所有的消费者处理，相当于订阅发布模式