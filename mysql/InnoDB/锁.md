---
tags: []
date created: 2022-03-30 04:09
date modified: 2023-11-22 20:00
title: 锁
---

# 全局锁

对整个数据库加锁，多用于全库备份
命令：`flush tables with read lock`
该命令会导致 DDL，DML 语句不能生效，可以使用 mysqldump 参数 --single-transaction，启动事务，拿到一致性视图
释放全局锁：`unlock tables`

# 表级锁

## 表锁

指定一个表加读或写锁
命令：`lock tables ... read/write`

## 元数据锁（MDL）

对数据库操作时，会自动给表加上 MDL，MDL 是为了保证当前用户对表执行 CRUD 操作时，防止其他线程对这个表结构做变更
- 对一张表进行 CRUD 操作时，加的是 MDL 读锁
- 对一张表做结构变更时，加的是 MDL 写锁
申请 MDL 锁的操作会形成一个队列，队列中写锁获取优先级高于读锁，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作

## 意向锁

在 InnoDB 引擎中对表里某些记录加共享锁/独占锁时，需要先在表级别加上一个意向共享锁/意向独占锁

**意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁和独占表锁发生冲突**

如果没有意向锁，那么在锁表时，就需要遍历表里的所有记录，查看是否有记录存在独占锁，这样效率会很慢。**意向锁的目的是为了快速判断表里是否有记录被加锁**

auto-inc 锁，在对大量数据进行插入时，会影响插入性能，因为另一个事务中的插入会被阻塞 MySQL5.1.22 InnoDB 引擎提供了一种轻量级的锁来实现自增。**在插入数据时，会为被 auto_increment 修饰的字段加上轻量级锁，然后给该字段赋值一个自增的值，就将这个轻量级锁释放，而不需要等待整个插入语句完成**

InnoDB 引擎提供一个系统变量，用来选择用 auto-inc 锁还是轻量级锁
- innodb_autoinc_lock_mode = 0，采用 auto-inc
- innodb_autoinc_lock_mode = 2，采用轻量级锁
- innodb_autoinc_lock_mode = 1
	- 普通 insert 语句，自增锁在申请之后就马上释放
	- 类似 `insert ... select` 的批量插入数据语句，自增锁还是要等语句结束才会被释放
当 mode=2，但是搭配 binlog 日志格式为 statement 时，会发生主从复制数据不一致的问题。**将 binlog 日志设为 row，可以解决，这样既能提升并发性又不会出现数据不一致的问题**

## AUTO-INC 锁

通过对主键字段声明 `auto_increment` 实现。
在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，主要是通过 auto-inc 锁实现。
auto-inc 锁是特殊的表锁机制，锁不再是一个事务提交后才释放，而是再执行完插入语句后就会立即释放

# 行锁

## 记录锁（Record lock）

`select * from t where id = 1 for update`
在 id=1 的记录上加行锁，阻止其他事务插入、更新、删除该行

## Gap Lock（间隙锁）

间隙锁，只存在于可重复读隔离级别，是为了解决可重复读隔离级别下幻读的现象
![](attachments/Pasted%20image%2020230404020853.png)
间隙锁之间时兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁是为了防止插入幻影记录而提出的。

## Next-Key Lock

Next-Key，是包含间隙锁 + 记录锁的，在可重复读级别下生效，它的范围包含索引记录和索引区间，是一个左开右闭区间。

在非唯一索引列上都会存在 next-key，在唯一索引（主键索引）上不存在 next-key。
