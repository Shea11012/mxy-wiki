---
tags: []
date created: 2023-03-07 00:46
date modified: 2023-03-10 08:46
---

## 三次握手

![tcp握手](attachments/tcp握手.png)

1. 客户端初始化连接将 SYN 置为 1，Seq 赋值一个随机数，由 close->SYN-SENT
2. 服务端将 SYN 和 ACK 置为 1，服务端 Seq 赋值一个随机数，并将客户端传来的 Seq+1 赋值给 Acknowledgment Number（确认应答号），服务端 close->SYN-RCVD
3. 客户端将 ACK 置为 1，将服务端的 Seq+1 赋值给确认应答号，客户端进入 established（这一次握手时，就可以携带数据了）
4. 服务端收到客户端的报文后，服务端也进入 established

>[!note]
>TCP 三次握手时，Linux 内核会维护两个队列，分别是：
>- 半连接队列（SYN 队列）
>- 全连接队列（accept 队列）
> 
> 1. 当服务端收到客户端的 SYN 报文时，会创建一个半连接对象，将其加入到 SYN 队列
> 2. 然后发送 SYN-ACK 给客户端，等待客户端回应 ACK
> 3. 服务端收到 ACK，将半连接对象取出，然后创建一个新的连接对象放入到 Accept 队列
> 4. 应用通过调用 accept 函数，从 accept 队列取出连接对象

### SYN 攻击

会把 TCP 半连接队列打满后续收到的 SYN 报文就会丢弃，导致无法建立连接
避免 SYN 攻击的方式：
- 调大 `netdev_max_backlog`
- 增大 TCP 半连接队列
- 开启 tcp_syncookies
- 减少 SYN-ACK 重传次数

## 四次挥手

![tcp挥手](attachments/tcp挥手.png)

- 主动方将 FIN 置为 1，发送报文后，进入 FIN-WAIT-1
- 被动方接受到 FIN 报文后，响应 ACK 报文，进入 CLOSE-WAIT
- 主动方收到被动方的 ACK 报文后，进入 FIN-WAIT-2
- 被动方发送完剩余数据后，发送 FIN 报文，进入 LAST_ACK
- 主动方接受到 FIN 报文，响应 ACK 报文，进入 TIME_WAIT
- 被动方收到 ACK 报文后，进入 close
- 主动发送完 ACK 后，在等待 2MSL 后，进入 close

## 为什么是三次握手，而不是两次或四次

### 三次握手才可以防止重复历史连接的初始化

当客户端发起一个 SYN1（seq=90）时，因为网络阻塞的缘故，客户端宕机重启重新发起了另一个 SYN2（seq=100），SYN1 先到达服务端时，返回的 ACK（90+1），客户端比较与预期的 100+1 不匹配，会发送一个 RST。

如果是两次握手，就无法发起阻止历史连接，就会导致服务的的资源浪费。

### 三次握手才可以同步双方的初始序列号

TCP 连接维护一个序列号，作用是：
- 接收方可以去除重复的数据
- 接收方可以根据数据包的序列号按序接受
- 可以标识发送出去的数据包中，哪些是已经被对方接受到的

四次握手也可以实现同步序列号，因为服务端的 SYN 和 ACk 可以合并到一起，就优化成了 3 次握手

### 三次握手才可以避免资源浪费