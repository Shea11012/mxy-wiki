---
date created: 2021-11-30 21:22
date modified: 2022-04-19 22:51
title: 进程和线程
---
## 进程
### 进程的状态
![](attachments/Pasted%20image%2020220419160017.png)
进程活动期间的状态：
- 运行状态：当前时刻进程占用 CPU
- 状态：可运行，由于其它进程处于运行状态而暂时停止运行
- 状态：该进程正在等待某一事件发生（如 IO 操作）而暂时停止运行

基本状态：
- 创建状态：进程正在被创建
- 结束状态：进行正在从系统中消失

### 进程控制结构 PCB
PCB（process control block）

PCB 包含信息
- 进程描述信息
	- 进程标识符，标识各个进程，每个进程都有一个且唯一的标识符
	- 用户标识符，进程归属用户，用户标识符主要为共享和保护服务
- 进程控制和管理信息
	- 进程当前状态，如 new、ready、running、waiting、blocked 等
	- 进程优先级，进行抢占 CPU 时的优先级
- 资源分配清单
	- 有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 IO 设备信息
- CPU 相关信息
	- CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行

操作系统通过链表的方式把具有相同状态的进程链在一起，组成各种队列，如：
- 所有处于就绪状态的进程链在一起，是就绪队列
- 所有因等待某事件而处于等待状态的进程，是阻塞队列

### 进程上下文切换
进程是由内核管理和调度的，所以进程的切换只能发生在内核态

进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源

发生进程切换的场景：
- 系统将 CPU 时间划分为一段段的时间片，将时间片轮流分配给各个进程，当某个进程的时间片耗尽时，进程就从运行态变为就绪态，系统从就绪队列选择另外一个进程运行
- 进程在系统资源不足时，要等待资源满足后才可以运行，这时进程也会被挂起，并由系统调度其它进程运行
- 进程通过睡眠函数 sleep 这类方法将自己主动挂起，也会重新调度
- 当优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行

## 线程
线程是进程当中的一条执行流程

同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源。每个线程各自有独立的寄存器和栈，这样可以确保线程的控制流是相对独立的。

**优点：**
- 一个进程中可以同时存在多个线程
- 各个线程之间可以并发执行
- 各个线程之间可以共享地址空间和文件等资源

**缺点：**
- 当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃

### 线程上下文切换
操作系统的任务调度，实际上的调度对象是线程，而进程只是给线程提供虚拟内存、全局变量等资源

当两个线程不是属于同一个进程，则切换的过程与进程上下文切换一样
当两个线程是属于同一个进程，因为虚拟内存时共享的，所在切换时，虚拟内存这些资源就保持不懂，只需要切换线程的私有数据、寄存器等不共享的数据

### 线程的实现
- 用户线程：在用户空间实现的线程，不是由内核管理的线程，由用户态的线程来完成线程的管理
- 内核线程：在内核中实现的线程，由内核管理的线程
- 轻量级线程：在内核中支持用户线程

## 线程与进程的区别

- 资源分配：资源分配基本单位是进程，线程是调度的基本单位
- 进程与进程之间是独立的，**一个进程的异常终止不会影响其它进程**，而线程与线程之间大部分是共享的，**一个线程的异常终止会影响其它线程，会使进程终止。**
- 线程与线程大部分共享，也有一部分私有数据：线程 ID、上下文、独享一个栈空间、错误码、信号屏蔽字、调度优先级
- 调度和切换：线程的上下文切换比进程上下文切换要快的多。
- 线程比进程占用的资源要小，线程的创建远小于进程的创建
- 线程之间资源共享，需要使用锁。
- 线程创建出来的线程是平等的，**进程的创建出的进程是该进程的子进程**


## 调度
### 调度时机
在进程的生命周期中，当进程从一个运行状态到另一个运行状态，就会触发一次调度

### 调度原则
- CPU 利用率：调度程序应确保 CPU 始终忙碌的状态，提高 CPU 的利用率
- 系统吞吐量：表示单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，短作业的进程会提升吞吐量
- 周转时间：进程运行和阻塞时间的总和，一个进程的周转时间越小越好
- 等待时间：等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间
- 响应时间：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准

### 调度算法
#### 先来先服务调度算法 FCFS（first come first served）
每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行

FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 IO 繁忙型系统

#### 最短作业优先调度算法 SJF（shortest job first）
优先选择运行时间最短的进程来运行

这对长作业不利，会造成长作业一直得不到调度的情况

#### 高响应比优先调度算法 HRRN（highest response ratio next）
权衡了短作业和长作业，每次进行调度时，先计算响应比优先级，然后把响应比优先级最高的进程投入运行，优先权公式：
$$
优先权=\frac{等待时间 + 要求服务时间}{要求服务时间}
$$

#### 时间片轮转调度算法 RR（Round Robin）
每个进程分配一个时间段，运行进程在该时间段中运行

#### 最高优先级调度算法 HPF（Highest Priority First）
从就绪队列中选择最高优先级的进程进行运行

进程的优先级分为：
- 静态优先级：创建进程时，就已经确定了优先级，以后的运行时间优先级都不会变化
- 动态优先级：根据进程的动态变化调整优先级，如果进程运行时间增加，则降低优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级

#### 多级反馈队列调度算法 （Multilevel Feedback Queue）
多级反馈队列算法是时间片轮转算法和最高优先级算法的结合
多级：有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短
反馈：如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，而去运行优先级高的运行


## 进程间通信
### 管道
![](attachments/Pasted%20image%2020220419202409.png)

管道时内核里的一段缓存，从管道的一端写入，实际上是写道内核的缓存中，读则是读取内核的这段缓存

管道的传输数据是无格式的流且大小受限

**缺点：**
管道的通信方式效率低，不适合进程间频繁的交换数据

### 消息队列
消息队列是保存在内核中的消息链表。在发送数据时，会分成一个个独立的数据单元，即消息体，消息体是用户自定义的数据类型，消息的发送方和接受方要约定好消息体的数据类型。

**缺点：**
- 消息队列不适合比较大数据的传输，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也有上限。
- 消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销，因为写入时发生一次用户态到内核态的拷贝，读取时发生一次从内核态到用户态的拷贝

### 共享内存
共享内存，就是拿出一块虚拟地址空间，映射到相同的物理内存中。
**缺点：**
- 对共享内存的写读写需要保证原子性

### 信号量
信号量是一个整型计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据

### 信号
对于异常情况下的工作模式，需要用信号的方式来通知进程

信号是进程间通信机制中唯一的异步通信机制，可以在任何时候发送信号给某一进程

### socket
socket 可以跨网络通信，也可以在同主机上进程间通信